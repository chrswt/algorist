{"version":3,"sources":["../../src/1-28-integerDivision.js"],"names":["integerDivision","numerator","denominator","NaN","originalDenominator","Math","abs","result","negative","console","log"],"mappings":";;AAAA;;;;;;;;;;AAUA;;AAEA,IAAMA,kBAAkB,SAAlBA,eAAkB,CAACC,SAAD,EAAYC,WAAZ,EAA4B;AAClD,MAAIA,gBAAgB,CAApB,EAAuB;AAAE,WAAOC,GAAP;AAAa,GADY,CACX;;AAEvC,MAAMC,sBAAsBC,KAAKC,GAAL,CAASJ,WAAT,CAA5B;AACA,MAAIK,SAAS,CAAb;AACA,MAAIC,WAAW,KAAf;;AAEA,MAAI,EAAEP,YAAY,CAAZ,IAAiBC,cAAc,CAAjC,MACDD,YAAY,CAAZ,IAAiBC,cAAc,CAD9B,CAAJ,EACsC;AACpC;AACAM,eAAW,IAAX;AACD;;AAEDP,cAAYI,KAAKC,GAAL,CAASL,SAAT,CAAZ;AACAC,gBAAcG,KAAKC,GAAL,CAASJ,WAAT,CAAd;;AAEA,SAAOD,YAAYC,WAAnB,EAAgC;AAC9BA,oBAAgB,CAAhB,CAD8B,CACX;AACnBK,eAAW,CAAX,CAF8B,CAEhB;AACf;;AAED,SAAOL,cAAcD,SAArB,EAAgC;AAC9BC,mBAAeE,mBAAf,CAD8B,CACM;AACpCG;AACD;;AAED,SAAOA,WAAW,CAAX,GAAe,CAAf,GACLC,WAAW,CAACD,MAAZ,GAAqBA,MADvB;AAED,CA5BD;;AA8BAE,QAAQC,GAAR,CAAYV,gBAAgB,EAAhB,EAAoB,CAApB,CAAZ,E,CAAqC;AACrCS,QAAQC,GAAR,CAAYV,gBAAgB,CAAC,EAAjB,EAAqB,CAArB,CAAZ,E,CAAsC;AACtCS,QAAQC,GAAR,CAAYV,gBAAgB,EAAhB,EAAoB,CAAC,CAArB,CAAZ,E,CAAsC;AACtCS,QAAQC,GAAR,CAAYV,gBAAgB,CAAC,EAAjB,EAAqB,CAAC,EAAtB,CAAZ,E,CAAwC;AACxCS,QAAQC,GAAR,CAAYV,gBAAgB,IAAhB,EAAsB,EAAtB,CAAZ,E,CAAwC","file":"1-28-integerDivision.js","sourcesContent":["/*\n * The Algorithm Design Manual, 2nd Edition\n * Steven S. Skiena\n * Interview Problems (I-28), p.30\n *\n * INTEGER DIVISION\n * Write a function to perform integer division without using either the / or *\n * operators. Find a fast way to do it.\n */\n\n/*jshint esversion: 6 */\n\nconst integerDivision = (numerator, denominator) => {\n  if (denominator === 0) { return NaN; } // Handle non-divisible cases\n\n  const originalDenominator = Math.abs(denominator);\n  let result = 1;\n  let negative = false;\n\n  if (!(numerator < 0 && denominator < 0) &&\n    (numerator < 0 || denominator < 0)) {\n    // Flag for negative input in either numerator or denominator\n    negative = true;\n  }\n\n  numerator = Math.abs(numerator);\n  denominator = Math.abs(denominator);\n\n  while (numerator > denominator) {\n    denominator <<= 1; // Bitshift to double the denominator\n    result <<= 1; // Double the result correspondingly\n  }\n\n  while (denominator > numerator) {\n    denominator -= originalDenominator; // Handle over-doubling by subtracting\n    result--;\n  }\n\n  return result === 0 ? 0 :\n    negative ? -result : result;\n};\n\nconsole.log(integerDivision(18, 3)); // 6\nconsole.log(integerDivision(-24, 2)); // -12\nconsole.log(integerDivision(39, -3)); // -13\nconsole.log(integerDivision(-42, -20)); // 2\nconsole.log(integerDivision(1000, 10)); // 100\n"]}